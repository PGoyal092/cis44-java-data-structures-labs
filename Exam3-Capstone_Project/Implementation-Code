//alogorithms and implementation
public class Task {
    private String id;
    private int priority;
    private long timestamp;

    public Task(String id, int priority, long timestamp) {
        this.id = id;
        this.priority = priority;
        this.timestamp = timestamp;
    }
    public String getId() {
        return id;
    }
    public int getPriority() {
        return priority;
    }
    public long getTimestamp() {
        return timestamp;
    }
    
    @Override
    public String toString() {
        return "Task[id=" + id + ", priority=" + priority + ", timestamp=" + timestamp + "]";
    }
}
-----------------------------------------------------------------------------------------------------------
import java.util.Comparator;
import java.util.PriorityQueue;

public class SmartScheduler {
    private PriorityQueue<Task> queue;
    public SmartScheduler() {
        queue = new PriorityQueue<>(new TaskComparator());
    }
    private static class TaskComparator implements Comparator<Task> {
        @Override
        public int compare(Task t1, Task t2) {
            // first checks priority
            if (t1.getPriority() != t2.getPriority()) {
                return Integer.compare(t1.getPriority(), t2.getPriority());
            }
            // if same priority, the one entered first is higher priority and will be taken out first
            return Long.compare(t1.getTimestamp(), t2.getTimestamp());
        }
    }
    public void addTask(Task task) { //adds new task to scheduler
        queue.add(task);
    }
    //triggers heap removal alogrithm
    public Task getNextTask() { //removes and returns highest-priority task (the one at the root)
        return queue.poll(); //phase 3 alogorithm
    }
    public Task peekNextTask() { //returns next task without removing
        return queue.peek();
    }
    public boolean isEmpty() { // returns true if scheduler is empty
        return queue.isEmpty();
    }
}
